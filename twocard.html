<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Card Game – Full Animated</title>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #020617;
      overflow: hidden;
      touch-action: none;
    }
  </style>
</head>
<body>

<script src="https://cdn.jsdelivr.net/npm/socket.io-client@4/dist/socket.io.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/pixi.js@7/dist/pixi.min.js"></script>
<script>
/* =========================
   SOCKET
========================= */
const socket = io("http://localhost:3000", {
  withCredentials: true
});

let ROOM_ID = null;
let PLAYER_KEY = null;

/* =========================
   PIXI APP
========================= */
const app = new PIXI.Application({
  resizeTo: window,
  antialias: true,
  backgroundAlpha: 0
});
document.body.appendChild(app.view);
app.stage.sortableChildren = true;

/* =========================
   CONFIG
========================= */
const CARD_W = 62;
const CARD_H = 92;
const OVERLAP = 22;
const CENTER_OFFSET = 30;
const THROW_SPEED = 0.12;

/* =========================
   STATE
========================= */
let playerHand = [];
let opponentHandCount = 0;
let centerPile = [];
let currentTurn = null;
let isAnimating = false;

let score = { player: 0, opponent: 0 };

/* =========================
   UI TEXT
========================= */
const turnText = new PIXI.Text("", { fill: 0xe5e7eb, fontSize: 18, fontWeight: "bold" });
turnText.anchor.set(0.5);
turnText.y = 16;

const scoreText = new PIXI.Text("", { fill: 0x94a3b8, fontSize: 14 });
scoreText.anchor.set(0.5);
scoreText.y = 50;

app.stage.addChild(turnText, scoreText);

/* =========================
   CARD FACTORIES
========================= */
function frontCard(rank, suit) {
  const c = new PIXI.Container();
  c.rank = rank;
  c.suit = suit;

  const bg = new PIXI.Graphics()
    .beginFill(0xffffff)
    .lineStyle(2, 0x020617)
    .drawRoundedRect(0, 0, CARD_W, CARD_H, 10)
    .endFill();

  const color = (suit === "♥" || suit === "♦") ? 0xe11d48 : 0x020617;

  const t1 = new PIXI.Text(rank + suit, { fontSize: 14, fill: color });
  t1.x = 6; t1.y = 4;

  const t2 = new PIXI.Text(suit, { fontSize: 28, fill: color });
  t2.anchor.set(0.5);
  t2.x = CARD_W / 2;
  t2.y = CARD_H / 2;

  c.addChild(bg, t1, t2);
  return c;
}

function backCard() {
  const c = new PIXI.Container();
  const bg = new PIXI.Graphics()
    .beginFill(0x1e293b)
    .lineStyle(2, 0x94a3b8)
    .drawRoundedRect(0, 0, CARD_W, CARD_H, 10)
    .endFill();
  c.addChild(bg);
  return c;
}

/* =========================
   ANIMATION
========================= */
function animateMove(card, toX, toY, onDone) {
  isAnimating = true;
  app.ticker.add(function move() {
    card.x += (toX - card.x) * THROW_SPEED;
    card.y += (toY - card.y) * THROW_SPEED;
    if (Math.abs(card.x - toX) < 1 && Math.abs(card.y - toY) < 1) {
      card.x = toX;
      card.y = toY;
      app.ticker.remove(move);
      isAnimating = false;
      onDone && onDone();
    }
  });
}

/* =========================
   INTERACTION
========================= */
function throwPlayerCard(card) {
  if (isAnimating || currentTurn !== PLAYER_KEY) return;

  socket.emit("play_card", {
    roomId: ROOM_ID,
    rank: card.rank,
    suit: card.suit
  });
}

/* =========================
   RENDER
========================= */
function updateUI() {
  turnText.text = currentTurn === PLAYER_KEY ? "Your Turn" : "Opponent’s Turn";
  turnText.x = app.screen.width / 2;
  scoreText.text = `You: ${score.player} | Opponent: ${score.opponent}`;
  scoreText.x = app.screen.width / 2;
}

function renderHands() {
  app.stage.children.filter(c => c.isHand).forEach(c => app.stage.removeChild(c));

  const y = app.screen.height - CARD_H - 24;
  const totalW = CARD_W + OVERLAP * (playerHand.length - 1);
  const startX = (app.screen.width - totalW) / 2;

  playerHand.forEach((card, i) => {
    card.x = startX + i * OVERLAP;
    card.y = y;
    card.zIndex = i;
    card.isHand = true;
    card.interactive = true;
    card.cursor = "pointer";
    card.on("pointertap", () => throwPlayerCard(card));
    app.stage.addChild(card);
  });

  const oppW = CARD_W + OVERLAP * (opponentHandCount - 1);
  const ox = (app.screen.width - oppW) / 2;

  for (let i = 0; i < opponentHandCount; i++) {
    const b = backCard();
    b.x = ox + i * OVERLAP;
    b.y = 24;
    b.isHand = true;
    app.stage.addChild(b);
  }
}

/* =========================
   SOCKET EVENTS
========================= */
socket.on("game_state", (state) => {
  if (state.player1 && state.player2) {
    if (state.player1.you) {
      PLAYER_KEY = "player1";
      applyState(state.player1);
    } else {
      PLAYER_KEY = "player2";
      applyState(state.player2);
    }
  } else {
    applyState(state);
  }
});

function applyState(state) {
  ROOM_ID = state.roomId;

  playerHand = state.you.hand.map(c => frontCard(c.rank, c.suit));
  opponentHandCount = state.opponent.handCount;
  score.player = state.you.score;
  score.opponent = state.opponent.score;
  currentTurn = state.turn;

  centerPile.forEach(e => app.stage.removeChild(e.card));
  centerPile = [];

  state.centerPile.forEach(entry => {
    const card = frontCard(entry.rank, entry.suit);
    card.x = app.screen.width / 2 - CARD_W / 2;
    card.y = entry.playedBy === PLAYER_KEY
      ? app.screen.height / 2 + CENTER_OFFSET
      : app.screen.height / 2 - CENTER_OFFSET;
    app.stage.addChild(card);
    centerPile.push({ card });
  });

  renderHands();
  updateUI();
}

/* =========================
   INIT
========================= */
socket.emit("create_room");
window.addEventListener("resize", renderHands);
</script>
