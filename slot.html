<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Endless Runner â€“ Mixed Obstacles</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: black;
    touch-action: none;
  }
  #ui {
    position: fixed;
    top: 20px;
    left: 20px;
    color: white;
    font-family: Arial, sans-serif;
    font-size: 20px;
    z-index: 10;
  }
</style>
</head>
<body>
<div id="ui">Coins: <span id="score">0</span></div>

<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script>
/* ========================
   SCENE
======================== */
const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x000000, 10, 60);

const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000);
camera.position.set(0, 5, 10);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(5, 10, 5);
scene.add(light);

addEventListener("resize", () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

/* ========================
   PLAYER
======================== */
let lane = 0, velY = 0, grounded = true;
let sliding = false, slideTimer = 0;

const player = new THREE.Mesh(
  new THREE.BoxGeometry(1, 2, 1),
  new THREE.MeshStandardMaterial({ color: 0xff3333 })
);
player.position.y = 1;
scene.add(player);

/* ========================
   INPUT
======================== */
function moveLeft() { lane = Math.max(-1, lane - 1); }
function moveRight() { lane = Math.min(1, lane + 1); }

function jump() {
  if (!grounded || sliding) return;
  velY = 0.38;
  grounded = false;
}

function slide() {
  if (!grounded || sliding) return;
  sliding = true;
  slideTimer = 20;
  player.scale.y = 0.5;
  player.position.y = 0.5;
}

addEventListener("keydown", e => {
  if (e.key === "ArrowLeft") moveLeft();
  if (e.key === "ArrowRight") moveRight();
  if (e.key === "ArrowUp") jump();
  if (e.key === "ArrowDown") slide();
});

// Touch
let sx = 0, sy = 0;
addEventListener("touchstart", e => {
  sx = e.changedTouches[0].screenX;
  sy = e.changedTouches[0].screenY;
});
addEventListener("touchend", e => {
  const dx = e.changedTouches[0].screenX - sx;
  const dy = e.changedTouches[0].screenY - sy;
  if (Math.abs(dx) > Math.abs(dy)) {
    if (dx > 40) moveRight();
    if (dx < -40) moveLeft();
  } else {
    if (dy < -40) jump();
    if (dy > 40) slide();
  }
});

/* ========================
   ROAD
======================== */
const roads = [];
for (let i = 0; i < 5; i++) {
  const r = new THREE.Mesh(
    new THREE.BoxGeometry(6, 0.1, 20),
    new THREE.MeshStandardMaterial({ color: 0x333333 })
  );
  r.position.z = -i * 20;
  scene.add(r);
  roads.push(r);
}

/* ========================
   OBSTACLES (MIXED)
======================== */
const obstacles = [];
const lanes = [-2, 0, 2];

function spawnObstacle() {
  const type = Math.random() < 0.5 ? "LOW" : "HIGH";

  let geom, y;
  if (type === "LOW") {
    geom = new THREE.BoxGeometry(1.5, 1, 1);
    y = 0.5; // JUMP over
  } else {
    geom = new THREE.BoxGeometry(1.5, 1.5, 1);
    y = 2.2; // SLIDE under
  }

  const obs = new THREE.Mesh(
    geom,
    new THREE.MeshStandardMaterial({ color: type === "LOW" ? 0xff8800 : 0x00ff00 })
  );

  obs.userData.type = type;
  obs.position.set(lanes[Math.floor(Math.random() * 3)], y, -60);
  scene.add(obs);
  obstacles.push(obs);
}
setInterval(spawnObstacle, 1500);

/* ========================
   COINS
======================== */
const coins = [];
function spawnCoin() {
  const c = new THREE.Mesh(
    new THREE.CylinderGeometry(0.5, 0.5, 0.2, 16),
    new THREE.MeshStandardMaterial({ color: 0xffd700 })
  );
  c.rotation.x = Math.PI / 2;
  c.position.set(lanes[Math.floor(Math.random() * 3)], 1.5, -60);
  scene.add(c);
  coins.push(c);
}
setInterval(spawnCoin, 1000);

/* ========================
   GAME STATE
======================== */
let speed = 0.4, score = 0, gameOver = false;
function endGame() {
  if (gameOver) return;
  gameOver = true;
  alert("Game Over!\nCoins: " + score);
  location.reload();
}

/* ========================
   LOOP
======================== */
function animate() {
  requestAnimationFrame(animate);
  speed += 0.00005;

  player.position.x += ((lane * 2) - player.position.x) * 0.12;

  // Gravity
  velY -= 0.02;
  player.position.y += velY;
  const groundY = sliding ? 0.5 : 1;
  if (player.position.y <= groundY) {
    player.position.y = groundY;
    velY = 0;
    grounded = true;
  }

  // Slide timer
  if (sliding && --slideTimer <= 0) {
    sliding = false;
    player.scale.y = 1;
    player.position.y = 1;
  }

  // Road
  roads.forEach(r => {
    r.position.z += speed;
    if (r.position.z > 10) r.position.z -= 100;
  });

  const playerBox = new THREE.Box3().setFromObject(player);

  // Obstacles
  for (let i = obstacles.length - 1; i >= 0; i--) {
    const o = obstacles[i];
    o.position.z += speed;
    if (o.position.z > 10) {
      scene.remove(o);
      obstacles.splice(i, 1);
      continue;
    }
    if (playerBox.intersectsBox(new THREE.Box3().setFromObject(o))) {
      endGame();
    }
  }

  // Coins
  for (let i = coins.length - 1; i >= 0; i--) {
    const c = coins[i];
    c.position.z += speed;
    c.rotation.z += 0.1;
    if (c.position.z > 10) {
      scene.remove(c);
      coins.splice(i, 1);
      continue;
    }
    if (playerBox.intersectsBox(new THREE.Box3().setFromObject(c))) {
      scene.remove(c);
      coins.splice(i, 1);
      score++;
      document.getElementById("score").textContent = score;
    }
  }

  camera.lookAt(player.position);
  renderer.render(scene, camera);
}
animate();
</script>
</body>
</html>
