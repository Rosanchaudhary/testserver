<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Endless Runner â€“ Mobile + Desktop</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: black;
      touch-action: none; /* IMPORTANT for mobile swipe */
    }
    #ui {
      position: fixed;
      top: 20px;
      left: 20px;
      color: white;
      font-family: Arial, sans-serif;
      font-size: 20px;
      z-index: 10;
    }
  </style>
</head>
<body>
  <div id="ui">
    <div id="score">Score: 0</div>
  </div>

  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <script>
    // ========================
    // SCENE SETUP
    // ========================
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x000000, 10, 60);

    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(0, 5, 10);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(5, 10, 5);
    scene.add(dirLight);

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // ========================
    // PLAYER
    // ========================
    let playerLane = 0;
    let velocityY = 0;
    let grounded = true;

    const player = new THREE.Mesh(
      new THREE.BoxGeometry(1, 2, 1),
      new THREE.MeshStandardMaterial({ color: 0xff3333 })
    );
    player.position.y = 1;
    scene.add(player);

    // ========================
    // DESKTOP INPUT
    // ========================
    document.addEventListener("keydown", e => {
      if (e.key === "ArrowLeft") moveLeft();
      if (e.key === "ArrowRight") moveRight();
      if (e.key === "ArrowUp") jump();
    });

    function moveLeft() {
      playerLane = Math.max(-1, playerLane - 1);
    }

    function moveRight() {
      playerLane = Math.min(1, playerLane + 1);
    }

    function jump() {
      if (!grounded) return;
      velocityY = 0.38;
      grounded = false;
    }

    // ========================
    // MOBILE TOUCH INPUT
    // ========================
    let touchStartX = 0;
    let touchStartY = 0;
    const SWIPE_THRESHOLD = 40;

    document.addEventListener("touchstart", e => {
      const t = e.changedTouches[0];
      touchStartX = t.screenX;
      touchStartY = t.screenY;
    });

    document.addEventListener("touchend", e => {
      const t = e.changedTouches[0];
      const dx = t.screenX - touchStartX;
      const dy = t.screenY - touchStartY;

      if (Math.abs(dx) > Math.abs(dy)) {
        if (dx > SWIPE_THRESHOLD) moveRight();
        if (dx < -SWIPE_THRESHOLD) moveLeft();
      } else {
        if (dy < -SWIPE_THRESHOLD) jump(); // swipe up
      }
    });

    // ========================
    // ROAD
    // ========================
    const roadSegments = [];
    const ROAD_LENGTH = 20;

    for (let i = 0; i < 5; i++) {
      const road = new THREE.Mesh(
        new THREE.BoxGeometry(6, 0.1, ROAD_LENGTH),
        new THREE.MeshStandardMaterial({ color: 0x333333 })
      );
      road.position.z = -i * ROAD_LENGTH;
      scene.add(road);
      roadSegments.push(road);
    }

    // ========================
    // OBSTACLES
    // ========================
    const obstacles = [];
    const lanes = [-2, 0, 2];

    function spawnObstacle() {
      const obs = new THREE.Mesh(
        new THREE.BoxGeometry(1, 2, 1),
        new THREE.MeshStandardMaterial({ color: 0x00ff00 })
      );

      obs.position.set(
        lanes[Math.floor(Math.random() * 3)],
        1,
        -60
      );

      scene.add(obs);
      obstacles.push(obs);
    }

    setInterval(spawnObstacle, 1400);

    // ========================
    // GAME STATE
    // ========================
    let speed = 0.4;
    let score = 0;
    let scoreTimer = 0;
    let gameOver = false;

    function endGame() {
      if (gameOver) return;
      gameOver = true;
      alert("Game Over!\nScore: " + score);
      location.reload();
    }

    // ========================
    // GAME LOOP
    // ========================
    function animate() {
      requestAnimationFrame(animate);

      speed += 0.00005;

      // Smooth lane movement
      const targetX = playerLane * 2;
      player.position.x += (targetX - player.position.x) * 0.12;

      // Gravity
      velocityY -= 0.02;
      player.position.y += velocityY;
      if (player.position.y <= 1) {
        player.position.y = 1;
        velocityY = 0;
        grounded = true;
      }

      // Move road
      roadSegments.forEach(r => {
        r.position.z += speed;
        if (r.position.z > 10) {
          r.position.z -= ROAD_LENGTH * roadSegments.length;
        }
      });

      // Obstacles + collision
      for (let i = obstacles.length - 1; i >= 0; i--) {
        const o = obstacles[i];
        o.position.z += speed;

        if (o.position.z > 10) {
          scene.remove(o);
          obstacles.splice(i, 1);
          continue;
        }

        const playerBox = new THREE.Box3().setFromObject(player);
        const obsBox = new THREE.Box3().setFromObject(o);

        if (playerBox.intersectsBox(obsBox)) {
          endGame();
        }
      }

      // Score
      scoreTimer++;
      if (scoreTimer % 10 === 0) {
        score++;
        document.getElementById("score").innerText = "Score: " + score;
      }

      camera.position.y += (5 - camera.position.y) * 0.05;
      camera.lookAt(player.position);

      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>
</html>
