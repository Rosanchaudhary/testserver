<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Endless Runner â€“ Ramps Added</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: black;
        font-family: Arial, sans-serif;
      }
      #ui {
        position: fixed;
        top: 20px;
        left: 20px;
        color: white;
        font-size: 20px;
        z-index: 10;
      }
      .overlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.85);
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        color: white;
        z-index: 20;
      }
      button {
        padding: 12px 30px;
        font-size: 18px;
        cursor: pointer;
      }
    </style>
  </head>

  <body>
    <div id="ui">Coins: <span id="score">0</span></div>

    <div id="startScreen" class="overlay">
      <h1>Endless Runner</h1>
      <p>Arrow Keys / Swipe</p>
      <button onclick="startGame()">Start</button>
    </div>

    <div id="gameOverScreen" class="overlay" style="display: none">
      <h1>Game Over</h1>
      <p>Coins: <span id="finalScore">0</span></p>
      <button onclick="restartGame()">Restart</button>
    </div>

    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
    <script>
      /* SCENE */
      const scene = new THREE.Scene();
      scene.fog = new THREE.Fog(0x000000, 10, 60);

      const camera = new THREE.PerspectiveCamera(
        75,
        innerWidth / innerHeight,
        0.1,
        1000
      );
      camera.position.set(0, 5, 10);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(innerWidth, innerHeight);
      document.body.appendChild(renderer.domElement);

      scene.add(new THREE.AmbientLight(0xffffff, 0.6));
      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(5, 10, 5);
      scene.add(light);

      addEventListener("resize", () => {
        camera.aspect = innerWidth / innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
      });

      /* PLAYER */
      let lane = 0,
        velY = 0,
        grounded = true;

      const player = new THREE.Mesh(
        new THREE.BoxGeometry(1, 2, 1),
        new THREE.MeshStandardMaterial({ color: 0xff3333 })
      );
      player.position.y = 1;
      scene.add(player);

      /* INPUT */
      addEventListener("keydown", (e) => {
        if (e.key === "ArrowLeft") lane = Math.max(-1, lane - 1);
        if (e.key === "ArrowRight") lane = Math.min(1, lane + 1);
        if (e.key === "ArrowUp" && grounded) {
          velY = 0.38;
          grounded = false;
        }
      });

      /* ROAD */
      const roads = [];
      for (let i = 0; i < 5; i++) {
        const r = new THREE.Mesh(
          new THREE.BoxGeometry(6, 0.1, 20),
          new THREE.MeshStandardMaterial({ color: 0x333333 })
        );
        r.position.z = -i * 20;
        scene.add(r);
        roads.push(r);
      }

      /* OBJECTS */
      const lanes = [-2, 0, 2];
      const obstacles = [];
      const coins = [];
      const ramps = [];

      function spawnObstacle() {
        const o = new THREE.Mesh(
          new THREE.BoxGeometry(1.5, 1.5, 1),
          new THREE.MeshStandardMaterial({ color: 0xff8800 })
        );
        o.position.set(lanes[Math.random() * 3 | 0], 0.75, -60);
        scene.add(o);
        obstacles.push(o);
      }

      function spawnCoin() {
        const c = new THREE.Mesh(
          new THREE.CylinderGeometry(0.5, 0.5, 0.2, 16),
          new THREE.MeshStandardMaterial({ color: 0xffd700 })
        );
        c.rotation.x = Math.PI / 2;
        c.position.set(lanes[Math.random() * 3 | 0], 1.5, -60);
        scene.add(c);
        coins.push(c);
      }

      function spawnRamp() {
        const ramp = new THREE.Mesh(
          new THREE.BoxGeometry(2, 0.2, 4),
          new THREE.MeshStandardMaterial({ color: 0x5555ff })
        );
        ramp.rotation.x = Math.PI / 6;
        ramp.position.set(lanes[Math.random() * 3 | 0], 0.1, -60);
        scene.add(ramp);
        ramps.push(ramp);
      }

      /* GAME STATE */
      let speed = 0.4;
      let score = 0;
      let gameStarted = false;
      let gameOver = false;
      let timers = [];

      function startGame() {
        document.getElementById("startScreen").style.display = "none";
        gameStarted = true;
        timers.push(setInterval(spawnObstacle, 1500));
        timers.push(setInterval(spawnCoin, 1000));
        timers.push(setInterval(spawnRamp, 3000));
      }

      function endGame() {
        if (gameOver) return;
        gameOver = true;
        gameStarted = false;
        timers.forEach(clearInterval);
        document.getElementById("finalScore").textContent = score;
        document.getElementById("gameOverScreen").style.display = "flex";
      }

      function restartGame() {
        [...obstacles, ...coins, ...ramps].forEach(o => scene.remove(o));
        obstacles.length = coins.length = ramps.length = 0;
        lane = 0;
        velY = 0;
        player.position.set(0, 1, 0);
        speed = 0.4;
        score = 0;
        gameOver = false;
        document.getElementById("score").textContent = 0;
        document.getElementById("gameOverScreen").style.display = "none";
        startGame();
      }

      /* LOOP */
      function animate() {
        requestAnimationFrame(animate);
        if (!gameStarted) return renderer.render(scene, camera);

        speed += 0.00005;
        player.position.x += (lane * 2 - player.position.x) * 0.12;

        velY -= 0.02;
        player.position.y += velY;

        let onRamp = false;
        const playerBox = new THREE.Box3().setFromObject(player);

        ramps.forEach((r) => {
          r.position.z += speed;
          if (playerBox.intersectsBox(new THREE.Box3().setFromObject(r))) {
            onRamp = true;
            grounded = true;
            velY = 0;
            player.position.y += 0.08;
          }
        });

        if (!onRamp && player.position.y <= 1) {
          player.position.y = 1;
          velY = 0;
          grounded = true;
        }

        roads.forEach((r) => {
          r.position.z += speed;
          if (r.position.z > 10) r.position.z -= 100;
        });

        obstacles.forEach((o) => {
          o.position.z += speed;
          if (playerBox.intersectsBox(new THREE.Box3().setFromObject(o)))
            endGame();
        });

        coins.forEach((c, i) => {
          c.position.z += speed;
          c.rotation.z += 0.1;
          if (playerBox.intersectsBox(new THREE.Box3().setFromObject(c))) {
            scene.remove(c);
            coins.splice(i, 1);
            score++;
            document.getElementById("score").textContent = score;
          }
        });

        camera.lookAt(player.position);
        renderer.render(scene, camera);
      }

      animate();
    </script>
  </body>
</html>
